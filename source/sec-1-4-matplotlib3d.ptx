<?xml version="1.0" encoding="UTF-8" ?>
<!-- This file is part of the book                      -->
<!--                                                    -->
<!-- An Introduction to Matrix Computations in Python   -->
<!--                                                    -->
<!-- Copyright (C) 2023  LBCC                           -->
<!-- See the file copyright.txt for copying conditions. -->

<section xml:id="section-matplotlib3d">
    
    <title>Matplotlib and 3D graphing</title>

    <introduction>
        Now that we have some experience making 2D graphs, let's learn how to make 3D graphs. 
        Note that we can graph both curves and surfaces in 3D.  
        If you have taken a multivariable class hopefully you remember that surfaces arise as solutions to equations of three variables,
        while points on a space curve are parametric equations or vector-valued functions. 
        The code for the points on a space curve is a little more straightforward so we will start with those examples.   
    </introduction>

    <objectives>
        <ul>
          <li>
            <p>
              Use Matplotlib to graph parametric curves in 3D.
            </p>
          </li>
          <li>
            <p>
              Use Matplotlib to graph surfaces and scatterplots in 3D. 
            </p>
          </li>
        </ul>
    </objectives>


      <subsection xml:id="subsec-3Daxes">
        <title>3D axes</title>

        <p>
          First, for 3D graphs we will need to add 3D axes to our figure using the keyword <c>projection='3d'</c>.
          Read through and run the code below to see the default 3D axes. 
        </p>

        <sage language='python'>
          <input>
              import matplotlib.pyplot as plt #import pyplot
              import numpy as np 

              fig = plt.figure() #create a figure
              ax = plt.axes(projection='3d') #add a 3D axis

              plt.show() #display the result
          </input>
        </sage>
        
      </subsection>

      <subsection xml:id="subsec-3DParam">
        <title>Parametric Curves in 3D</title>

        <p>
          Matplotlib graphs 3D curves by plotting points and connecting the dots.
          The <m>x</m>, <m>y</m>, and <m>z-</m>coordinates are still given by numpy arrays and then plotted on the axes.
        </p>

        <p>
          Run the code below to graph the equation of a line between the points <m>(1,1,1)</m> and <m>(2,3,4)</m>.
        </p>

        <sage>
          <input>
            import matplotlib.pyplot as plt
            import numpy as np

            fig = plt.figure() #create a figure
            ax = plt.axes(projection='3d') #add a 3D axis

            X = [1,2] #determine two x-values for the line
            Y = [1,3] #determine two y-values for the line
            Z = [1,4] #determine two z-values for the line

            ax.plot(X,Y,Z)
            plt.show()
            
          </input>
        </sage>

        <exercise>
          <p>
            Edit the above code to graph the equation of a line between the points <m>(1,2,3)</m> and <m>(4,5,6)</m>. 
          </p>
        </exercise>

        <exercise>
          <p>
            Edit the above code to add a third number to each numpy array. 
            What happens? Can you explain what <c>plot()</c> just graphed? 
          </p>
        </exercise>

        <p> We can also graph curves by making coordinates dependent on another. 
          For example, the curve below looks like a parabola in the <m>z</m>-direction above the shadow <m>y=x</m>
        </p>

        <sage>
          <input>
            import matplotlib.pyplot as plt
            import numpy as np

            fig = plt.figure() #create a figure
            ax = plt.axes(projection='3d') #add a 3D axis

            X = np.linspace(-6,6, num=10) #10 x-values
            Y = X #corresponding y-values along y=x
            Z = X**2 #corresponding z-values above y=x

            ax.plot(X,Y,Z)
            plt.show()
            
          </input>
        </sage>

        <p>
          As before, we need enough input points to get a smooth curve. 
        </p>
        <p>
          Parametric curves in 3D are just like 2D (see (<xref ref="section-matplotlib"/>)) with an added <m>z</m>-coordinate. 
          For example, we can graph a horizontal circle at <m>z=1</m> using 
          <ul>
            <li>
              <m>x=\cos(t)</m>
            </li>
            <li>
              <m>y=\sin(t)</m>
            </li>
            <li>
              <m>z=1</m>
            </li>
          </ul>
        </p>

        <sage>
          <input>
            import matplotlib.pyplot as plt
            import numpy as np

            fig = plt.figure() #create a figure
            ax = plt.axes(projection='3d') #add a 3D axis

            T = np.linspace(0,2*np.pi, num=25) #25 input parameter values
            X = np.cos(T) #corresponding x-values
            Y = np.sin(T) #corresponding y-values 
            Z = 1 #corresponding z-values

            ax.plot(X,Y,Z)
            plt.show()
            
          </input>
        </sage>

        <exercise>
          <p>
            Play with the above code for <m>x</m>, <m>y</m>, and <m>z</m> to see what other interesting curves you can create.  
          </p>
          <p>
            In 3-space can you graph
            <ul>
              <li>
                a line?
              </li>
              <li>
                a spiral?
              </li>
              <li>
                a different circle?
              </li>
            </ul> 
          </p>
        </exercise>


      </subsection>



      <subsection xml:id="subsec-Graphing-a-surface">
        <title>Surfaces and scatterplots in 3D</title>
        
        <p>
          To graph a surface or 3D scatterplot, message:%3C50e01ad67844753009c9c73ad.0e9370b65c.20231227234403.88b23917cf.2628a78c@mail33.atl91.mcsv.net%3Ewe will need two-dimensional numpy arrays for all of our inputs and outputs.
          As a shortcut we can create 1D arrays for the <m>x</m> and <m>y</m> inputs first, then use NumPy's function <c>meshgrid()</c> to create a coordinate grid of inputs (two 2D arrays). 
          Last we define our outputs on that coordinate grid.
        </p>
        <p>
          The function <c>scatter()</c> will plot a scatterplot just like in 2D.
          The function <c>plot_surface()</c> plots the points and connect those dots with a surface.  
          Just like we need enough points to get a curve that looks smooth, 
          we will need enough points to get a surface that looks smooth.
        </p>

        <exercise>
          <p> Run the code below trying both the command <c>plot_surface()</c> (current default) and <c>scatter()</c> to see the difference.  
          </p>
        </exercise>


        <sage language='python'>
          <input>
              import matplotlib.pyplot as plt #import pyplot
              import numpy as np 

              fig = plt.figure() #create a figure
              ax = plt.axes(projection='3d') #add a 3D axis
              X = np.arange(-2,2,step=0.25) #1D x-inputs
              Y = np.arange(-2,2,step=0.25) #1D y-inputs
              X,Y = np.meshgrid(X,Y) #2D coordinate input grid
              Z = X**2+Y**2 #determine outputs x^2+y^2

              ax.plot_surface(X,Y,Z) #plot surface
              plt.show() #display the result
          </input>
        </sage>

        <exercise>
          <p> For the surface, increase the step in each input and run the above code again. 
            When does the surface start to look <q>polygonal</q> instead of smooth?  
          </p>
        </exercise>

        <exercise>
          <p> Modify the above code to graph the surface <m>z=sin(y)</m>.
            Choose a reasonable range of inputs that shows the important features of the graph.   
          </p>
        </exercise>

        <exercise>
          <p> Change the surface to <m>z=sin(xy)</m>. 
            What step size is needed to make the input window [-2,2] and [-2,2] display a smooth surface? 
          </p>
        </exercise>

        <p>
          As in the 2D case, the function <c>scatter()</c> plots the points without connecting the dots. 
        </p>

      </subsection>

      <subsection xml:id="subsec-3DAxesandLabels">
        <title>Axes and Labels</title>

        <p>
          Adding titles or labels to our 3D axes uses the same commands as in 2D. the commands <c>set_title("title_here")</c>, 
          <c>set_xlabel("label_here")</c>, <c>set_ylabel("label_here")</c>. 
          Since the code below is longer, you might need to scroll to see all of the commands. 
        </p>

        <sage language='python'>
          <input>
              import matplotlib.pyplot as plt #import pyplot
              import numpy as np 

              fig = plt.figure() #create a figure
              ax = plt.axes(projection='3d') #add a 3D axis
              X = np.arange(-2,2,step=0.25) #1D x-inputs
              Y = np.arange(-2,2,step=0.25) #1D y-inputs
              X,Y = np.meshgrid(X,Y) #2D grid of inputs
              Z = X**2+Y**2 #determine outputs 

              ax.set_xlabel('X') #label x-axis
              ax.set_ylabel('Y') #label y-axis

              ax.set_title("My surface") #title my graph

              ax.plot_surface(X,Y,Z) #plot surface
              plt.show() #display the result
          </input>
        </sage>

        <exercise>
          <p> In the above code, use parallel syntax to add a label to the <m>z</m>-axis. 
          </p>
        </exercise>

        <p>
          Note that the default viewing window makes the <m>x</m>-axis positive left to right and <m>y</m>-axis positive front to back.
          Something new in the 3D setting, however, is the ability to choose our viewing angle for the 3D axes using <c>view_init(elev= , azim=, roll=)</c>. 
        </p>

        <exercise>
          <p> In the code below, play with the values for <c>elev</c>, <c>azim</c> and <c>roll</c>.
          </p>
          <ul>
            <li>
              What does each change?
            </li>
            <li> 
              What custom viewing angle do you think showcases this particular surface the best? 
            </li> 
          </ul>
        </exercise>

        <sage language='python'>
          <input>
              import matplotlib.pyplot as plt #import pyplot
              import numpy as np 

              fig = plt.figure() #create a figure
              ax = plt.axes(projection='3d') #add a 3D axis
              X = np.arange(-2,2,step=0.25) #1D x-inputs
              Y = np.arange(-2,2,step=0.25) #1D y-inputs
              X,Y = np.meshgrid(X,Y) #2D grid of inputs
              Z = X**2+Y**2 #determine outputs 

              ax.set_xlabel('X') #label x-axis
              ax.set_ylabel('Y') #label y-axis
              ax.set_ylabel('Z') #label z-axis

              # Customize the view angle 
              ax.view_init(elev=20, azim=30, roll=0)

              ax.plot_surface(X,Y,Z) #plot surface
              plt.show() #display the result
          </input>
        </sage>
        
      </subsection>

      <subsection>
        <title>Customizing</title>

        <p> Custom colors, meshes, contours, etc? What else should go here? 
        </p>

      </subsection>



      <conclusion>
        Add conclusion here. More. and more. And more.
      </conclusion>

      <assemblage><!--to assemble or summarize important connected ideas-->
        <title> Summary </title>
        <p>
        <ul>
          <li>
            <p>
              We can add 3D axes using the argument <c>projection='3d'</c> inside pyplot's <c>axes</c> command.
            </p>
          </li>
          <li>
            <p>
              We graph curves on our 3D axes using <c>axes_name.plot(array x, array y, array z)</c> .  
            </p>
          </li>
          <li>
            <p>
              We can use <c>numpy.meshgrid()</c> to create input coordinates on a grid and then use <c>plot_surface()</c> or <c>scatter()</c> 
              to plot a surface or scatter plot on 3D axes. 
            </p>
          </li>
          <li>
            <p>
              As before we need enough points for <c>plot_surface()</c> or <c>plot()</c> to make smooth graphs. 
            </p>
          </li>
        </ul>
      </p>
      </assemblage>



</section>